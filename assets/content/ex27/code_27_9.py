from math import dist

def isolated(cl):
    # Создаем массив для сравнения
    m = []  
    # Перебираем все точки кластера
    for p in cl:  
        # Считаем количество точек в единичной окрестности
        k = len([p1 for p1 in cl if dist(p, p1) <= 1])
        # Сохраняем информацию о точке: кол-во соседей, 
        # координата -Y (чтобы минимум взял большую точку за 
        # минимум), сама точка
        m.append([k, -p[1], p])
    # Возвращаем точку с минимальным количеством соседей, 
    # а если таких точек несколько, выбирается та, 
    # у которой наибольшая координата Y
    return min(m)[2]